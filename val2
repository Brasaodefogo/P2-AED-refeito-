#!/usr/bin/perl -w
eval 'exec /usr/bin/perl -S $0 ${1+"$@"}' if 0; $0 =~ s/^.*?(\w+)[\.\w+]*$/$1/;
# Code generated by a simple perlobfuscator written by paulo.flores@inesc-id.pt
BEGIN{$^W=1;}my($rcsid)='$Id: created on 2019-10-19 by Paulo Flores $';use strict;use warnings;use English;local$|=1;my$PROGRAM=q[val2: Validador proj.2 - 'Pares de Palavras' - AED (2023/24, P4) LEE];my$COPYRIGHT='Copyright (C) by Paulo Flores <paulo.flores@tecnico.ulisboa.pt>';my$VERSION='Ver. 1.0 2024-04-26';my$MAX_ERRORS=10000000000.0;my$REDUCE_MAX_ERRORS=10;my$Errors=0;use Getopt::Long;our($help,$verb,$dbg)=(0,0,0);our$output=0;our$rel=0;our$wso=0;our$msk=0;our$prt=0;if($PROGRAM_NAME eq 'ppal'){();}my$result=&GetOptions('help|h',\$help,'verb',\$verb,'dbg',\$dbg,'rel|r',\$rel,'output|o',\$output,'wso|solve|s',\$wso,'msk|mooshak',\$msk,'prt|print|p',\$prt);if($help){usage();mydie("die reading help line command - invalid/unknown options.\n");}my$CLASSIFY_CODE=defined$ENV{'CLASSIFY_CODE'}?$ENV{'CLASSIFY_CODE'}:0;if($CLASSIFY_CODE>2){printf STDERR "Error detected, output verification skipped.($CLASSIFY_CODE)\n";close STDERR;close STDOUT;myexit($CLASSIFY_CODE);}if($#ARGV<0){usage();mydie("missing files.\n");mydie(q[Can't open input STDIN])unless open Ftxt,'-';$wso=1;}my$txtfile='-';if(defined$ARGV[0]){$txtfile=$ARGV[0];print"OPEN TXT FILE: $txtfile\n" if$dbg;mydie("Can't open input problem file: $txtfile\n")unless open Ftxt,"$txtfile";}my$solfile='';if(defined$ARGV[1]){$solfile=$ARGV[1];mydie("Can't open input solution file: $solfile\n")unless open Fsol,"$solfile";$wso=0;print"OPEN SOL FILE: $solfile\n" if$dbg;}else{usage();mydie('Missing solution file.');if($msk){mydie('Under mooshak a student solution file is required.');}$wso=1;if($output==0){$output=$txtfile;$output=~s/\.txt$/.sol/;}else{$output='-';}}my($N,$NWORDS)=(undef,undef);my(%pairC)=();my(%pairW)=();my(@STDsol)=();my(%STDsolFreq)=();my(%STDsolCnt)=();my(@SOLW)=();my(%SOLfreqW)=();my(%SOLcntW)=();if($rel){$MAX_ERRORS=$REDUCE_MAX_ERRORS;}my$PRT_ERRORS=1;my$Errors_line=0;sub main{}read_problem();if($msk){solve_problemW();}else{solve_problemW();}unless($wso){read_solution_std();}if($wso and not$msk){write_solutions();}else{compCheck_solutions();}if($wso){$Errors=999999999;close STDERR;close STDOUT;myexit(0);}printf STDERR "Files: $txtfile $solfile    Errors: $Errors \n";close STDERR;close STDOUT;if($Errors==0){myexit(0);}else{myexit(2);}myexit(6);sub read_problem{my$linetxt=readline Ftxt;unless(defined$linetxt){usage();mydie("die reading input problem - invalid/unknown values.\n");}chomp$linetxt;($N)=$linetxt=~/\s*(\d+)\s*/g;$linetxt=readline Ftxt;chomp$linetxt;($NWORDS)=$linetxt=~/\s*(\d+)\s*/g;unless(defined$N){mydie('N is not defined in the text file');}unless(defined$NWORDS){mydie('Number of different words is not defined in the text file');}my$firstword=undef;my$secondword=undef;while(defined($linetxt=readline Ftxt)){chomp$linetxt;my@words=split(/\s+/,$linetxt,0);foreach my $word(@words){$word=lc$word;if($word eq ''){next;}unless(defined$firstword){$firstword=$word;next;}$secondword=$word;my$prevchar=substr($firstword,-1,1);my$nextchar=substr($secondword,0,1);printf"= $firstword \t $secondword\n" if$dbg;my$pairW="$firstword $secondword";if(defined$SOLfreqW{$pairW}){++$SOLfreqW{$pairW};}else{$SOLfreqW{$pairW}=1;}$firstword=$secondword;}}close Ftxt;return;}sub solve_problemC{return;}sub freqdecreasingC{}sub solve_problemW{print"Solving P2 $txtfile\n" if$wso;my$i=0;foreach my $pairW(sort freqdecreasingW keys%SOLfreqW){my$freq=$SOLfreqW{"$pairW"};$SOLW[$i++]="$freq $pairW";print"\t[$i - $freq $pairW]\n" if$dbg;if($i<=$N){if(not defined$SOLcntW{$freq}){$SOLcntW{$freq}=1;}else{++$SOLcntW{$freq};}}else{();}}return;}sub freqdecreasingW{return$SOLfreqW{$b}<=>$SOLfreqW{$a};}sub read_solution_prof{if(defined$ARGV[2]){my$solfileprof=$ARGV[2];mydie("Can't open Psol file for: $txtfile\n")unless open PSOL,"$solfileprof";}else{mydie("No Psol file defined.\n");}while(defined($_=readline PSOL)){chomp$_;}close PSOL;return;}sub read_solution_std{my$lines=0;my$pfreq=undef;while(defined($_=readline Fsol)){chomp$_;++$lines;if(/^\s*(\d+)\s+-\s+(\d+)\s+(\w+|\d+)\s+(\w+|\d+)\s*$/g){if($lines!=$1){prtmsg("ERR (line $lines): Sequencia de dados incorrecta: $_\n");++$Errors;}my$freq=$2;my$pair="$3 $4";$STDsol[$lines]="$freq $pair";$STDsolFreq{$pair}=$freq;if(not defined$STDsolCnt{$freq}){$STDsolCnt{$freq}=1;}else{++$STDsolCnt{$freq};}if(defined$pfreq and$pfreq<$freq){prtmsg("ERR (line $lines): A frequencia de sequencia nao esta decrescente: $_\n");++$Errors;}if(not defined$SOLfreqW{$pair}){prtmsg("ERR (line $lines): Par de palavras inexistentes: $_\n");++$Errors;}else{if($STDsolFreq{$pair}!=$SOLfreqW{$pair}){prtmsg("ERR (line $lines): Frequencia errada para o par: $_\n");++$Errors;}}$pfreq=$freq;}elsif(/^\s*$/g){();}else{prtmsg("ERR (line $lines): Formatacao de dados incorrecta: $_\n");++$Errors;}}if($lines==0){prtmsg("ERR (line $lines): Ficheiro de solucao vazio.\n");++$Errors;return;}close Fsol;return;}sub write_solutions{if($msk){mydie("Should not being writing solution of the problem P2\n");}if($output eq '-'){die q[Can't open output STDOUT] unless open FSOL,'>&STDOUT';}else{die"Can't open output file: $output" unless open FSOL,">$output";}my$TopMax=$N>$#SOLW+1?$#SOLW+1:$N;for(my$i=1;$i<=$TopMax;++$i){printf FSOL "$i - %s\n",$SOLW[$i-1];}if($prt){printf"SOLUTION -2- \t $output \t Top $N ($TopMax)\n";for(my$i=1;$i<=$TopMax;++$i){printf"$i - %s\n",$SOLW[$i-1];}}close FSOL;return;}sub compCheck_solutions{foreach my $freq(sort{$b<=>$a}keys%SOLcntW){unless(defined$STDsolCnt{$freq}){prtmsg("ERR: Faltam solucoes com a frequencia $freq\n");++$Errors;next;}my$difer=$SOLcntW{$freq}-$STDsolCnt{$freq};if($difer!=0){my$msg=$difer<0?'em excesso':'em falta';prtmsg("ERR: Numero de solucoes apresentadas com frequencia $freq errado ($msg)\n");++$Errors;}}my$TopMax=$N>$#SOLW+1?$#SOLW+1:$N;if($#STDsol!=$TopMax){my$msg=$#STDsol>$TopMax?'em excesso':'em falta';prtmsg("ERR: Numero de solucoes apresentadas errado ($msg)\n");++$Errors;}return;}sub cost_mov{my($seq)=@_;return int log($seq+1)/0.69314718055994528623;}sub sign{my($a)=@_;return$a<=>0;}sub min{my($a,$b)=@_;return$a<$b?$a:$b;}sub numOrd{my($a,$b)=@_;return$a<=>$b;}sub prtmsg{my($msg)=@_;if($PRT_ERRORS==1){if($Errors-$Errors_line<=$MAX_ERRORS){printf$msg;}else{printf"INF: Maximum number of $MAX_ERRORS errors exceeded. No more errors showed.\n";$PRT_ERRORS=0;}}return;}sub Exit{printf STDERR "XXXX Files: $txtfile $solfile  Errors: $Errors\n";return;}sub mydie{my($msg)=@_;printf STDERR "$msg\n";close STDERR;close STDOUT;myexit(1);return;}sub myexit{my($exitVal)=@_;exit$exitVal;}sub usage{my$cmd=`basename $0`;chomp$cmd;print STDERR "\n$PROGRAM\n$COPYRIGHT\n$VERSION\n\nUsage: $cmd [options] prob.txt prob.sol\n\n    -help -h    this help message\n    -verb       print verbose information\n    -dbg        print debug information\n    -rel\treduce the number of errors listed to $REDUCE_MAX_ERRORS\n\n    prob.txt    file with the problem\n    prob.sol\tfile with the solution in correct format\n\n";printf"\t    $rcsid\n\n" if$verb or$dbg;return;} # SDJ8DR
# Code generated by a simple perlobfuscator written by paulo.flores@inesc-id.pt
